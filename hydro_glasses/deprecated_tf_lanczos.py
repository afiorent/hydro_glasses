import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
#from ase.io import read,write
import opt_einsum as oe
#from scipy.optimize import curve_fit

def continued_fraction(a_coefficients, b_coefficients):
    """
    Computes the value of a continued fraction given lists of its a and b coefficients.

    Args:
        a_coefficients (list or ndarray): List of 'a' coefficients of the continued fraction.
        b_coefficients (list or ndarray): List of 'b' coefficients of the continued fraction.

    Returns:
        float or complex: Value of the continued fraction.
    """
    n = len(a_coefficients)
    if n == 0:
        return 0
    elif n == 1:
        return a_coefficients[0] + b_coefficients[0]
    else:
        return a_coefficients[0] + b_coefficients[0] / continued_fraction(a_coefficients[1:], b_coefficients[1:])



def lanczos_cheap(A, v, k, last2=False):
    """
    Lanczos algorithm for a symmetric matrix A and initial vector v.

    Args:
        A (ndarray): Symmetric matrix of shape (n, n).
        v (ndarray): Initial vector of shape (n,).
        k (int): Number of iterations.
        last2 (bool, optional): If True, also returns the last two vectors.

    Returns:
        tuple: (alpha_array, beta_array) or (alpha_array, beta_array, v, v_minus) if last2 is True.
    """
    n = A.shape[0]
    #T = np.zeros((k, k))
    alpha_array=np.zeros(k)
    beta_array=np.zeros(k)
    v = v / np.linalg.norm(v)
    v_minus=np.zeros_like(v,dtype=complex)
    for j in range(k):
        w =A@v # np.matmul(A, v,dtype=complex)
        alpha = np.real( np.vdot(v, w) ) 
        if j == k-1:
            break
        w = w - alpha * v - (beta * v_minus if j > 0 else 0)
        beta = np.linalg.norm(w)
        #print(beta)
        if beta == 0:
            break
        v_minus=v
        v=w / beta
        alpha_array[j] = alpha
        beta_array[j] = beta

    return alpha_array, beta_array#T, Q

def lanczos_sparse_complex(A, v, k):
    """
    Performs the Lanczos method to find an orthonormal basis for the Krylov space generated by v.

    Args:
        A: sparse and real/symmetric square matrix represented as a tf.sparse.SparseTensor object
        v: complex vector of dimension n represented as a tf.Tensor object
        k: number of basis vectors to compute (must be <= n-1)

    Returns:
        tuple: (alpha_array, beta_array)
            alpha_array (ndarray): Diagonal elements of the tridiagonal matrix.
            beta_array (ndarray): Off-diagonal elements of the tridiagonal matrix.
    """
    n = v.shape[0]
    alpha_array=np.zeros(k,dtype=complex)
    beta_array=np.zeros(k,dtype=complex)
    beta = tf.constant(0, dtype=tf.complex128)
    v = v / tf.norm(v)
    v_minus=tf.zeros_like(v)
    for j in range(k):
        w = tf.sparse.sparse_dense_matmul(A,v  )

        alpha = np.real(tf.math.reduce_sum(tf.math.conj(v) * w))
        w = w - alpha * v - beta * tf.cast(v_minus, dtype=tf.complex128)
        beta = tf.norm(w)
        if beta == 0:
            break
        v_minus=v
        v=w / beta
        alpha_array[j] = alpha
        beta_array[j] = beta
    return alpha_array,beta_array

def lanczos(A, v, k):
    """
    Implementation of the Lanczos algorithm for a symmetric matrix A and initial vector v.

    Args:
        A (ndarray): Symmetric matrix of dimension n x n.
        v (ndarray): Vector of dimension n x 1.
        k (int): Number of iterations.

    Returns:
        tuple: (alpha_array, beta_array, Q)
            alpha_array (ndarray): Diagonal elements of the tridiagonal matrix.
            beta_array (ndarray): Off-diagonal elements of the tridiagonal matrix.
            Q (ndarray): Matrix of dimension n x k, containing the Lanczos vectors.
    """
    n = A.shape[0]
    Q = np.zeros((n, k),dtype=complex)
    T = np.zeros((k, k))
    
    Q[:, 0] = v / np.linalg.norm(v)
    
    for j in range(k):
        w = np.matmul(A, Q[:, j],dtype=complex)
        alpha = np.vdot(Q[:, j], w)
        if j == k-1:
            break
        w = w - alpha * Q[:, j] - (T[j, j-1] * Q[:, j-1] if j > 0 else 0)
        beta = np.linalg.norm(w)
        if beta == 0:
            break
        Q[:, j+1] = w / beta
        T[j, j] = alpha
        T[j, j+1] = beta
        T[j+1, j] = beta

    alpha_array=np.diagonal(T)
    beta_array=np.zeros(k)    
    beta_array[:-1]=np.diagonal(T,offset=1)
    return alpha_array, beta_array,Q#T, Q
    #return T,Q
def compute_b2(beta):
    b2=np.zeros(len(beta)+1,dtype=complex)
    b2[0]=1+0*1j
    b2[1:]=-beta**2
    return b2

def spectrum(A, v, k, omega_array, eta, is_tf=False):
    """
    Compute spectrum using Lanczos method.

    Args:
        A (ndarray): Symmetric matrix of dimension n x n.
        v (ndarray): Vector of dimension n x 1.
        k (int): Number of iterations.
        omega_array (ndarray): Array of angular frequencies.
        eta (float): Imaginary part of z = omega + i*eta.
        is_tf (bool, optional): If True, uses TensorFlow sparse implementation.

    Returns:
        tuple: (omega_array, spectrum)
            omega_array (ndarray): Input angular frequency array.
            spectrum (ndarray): Computed spectrum values.
    """
    if not is_tf:
        alpha,beta=lanczos_cheap(A,v,k)
    else:
        alpha,beta=lanczos_sparse_complex(A,v,k)
    b2=compute_b2(beta)
    y=np.zeros_like(omega_array,dtype=complex)
    for i,omega in enumerate(omega_array):
        z2=(omega+1j*eta)**2
        y[i]=continued_fraction(np.insert(z2-alpha,0,0),b2)
    return omega_array, np.abs(np.imag(y))

